/* ifs.cc */

struct Ball;

class ifs{
	public:
		// data defining IFS and display and adjust options
		/* IFS is generated by two similarities; one scales by z and is centered at 0,
		the other scales by w and is centered at 1. */
		cpx z,w;		// parameters for IFS
		double az, aw;  //absolute values of them
		bool color_ifs;	// draw fL and gL in different colors
		bool chunky_ifs;       //draw the ifs with chunky balls
		double chunky_radius;  //the radius of the balls
		int sync;		// sync=0 w is arbitrary, sync=1 w=z, sync=2 w=-z
		int depth;		// depth to recurse to draw or detect connectedness
		int exit_depth;	// size of tree to detect connectedness
		cpx seed;		// initial seed for IFS in ifs mode
		double step;	// step size to adjust z or w in ifs mode
		cpx center;		// center of screen in mandelbrot mode
		double wind;	// size of window in mandelbrot mode
		int mesh;		// size of mesh in mandelbrot mode in pixels
		int mode;		// draw mode: 0 for limit set, 1 for mandelbrot set
		
		bool disconnection_depth; // whether to draw the depth for disconnected sets
		
		//these are trap variables and functions
		bool draw_trap_mode;      //whether to check for a trap and draw it in limit set mode
		int trap_depth;           //maximal depth to look for traps
		Trap current_trap;        //the last trap we created
		Ball act_on_left(int index, const Ball& b);
		void compute_next_ball_depth(std::vector<Ball>& balls, int current_depth);
		void compute_balls(std::vector<Ball>& balls, const Ball& ball_seed, int compute_depth);
		
						
		// default initial values
		
		void initialize(cpx a, cpx b);
		
		// apply generator; should really make this function more flexible
		
		cpx iterate(int index, cpx u);
		
				
		// test connectedness of limit set
		
		bool circles_intersect(cpx c1, cpx a1, cpx c2, cpx a2, double R, int d); // recursive test; do circles intersect?
		bool circ_connected();	// circle algorithm to test for connectedness
				
		
		// find and draw a trap
		
		bool find_trap();
		void draw_trap();		
		
		// draw limit set
		
		void draw_dots(int depth, cpx u);
		void draw_color_dots(int d, cpx u, long color);
		void draw_color_chunky_dots(int d, cpx u, long color, double radius);
		void compute_chunky_radius();
		

		void draw_limit_set();
		
		// draw mandelbrot set
		
		void zoom(point p);
		void draw_mandelbrot_set();
		
		// overall draw
		
		void draw();
		
		// user interface
			
		void user_interface();
};



void ifs::compute_chunky_radius() {
  //initialize the chunky radius to contain the whole set
  double z_restriction = abs(0.5*z-0.5)/(1.0-az);
	double w_restriction = abs(0.5-0.5*w)/(1.0-aw);
  chunky_radius = (z_restriction > w_restriction 
                                  ? z_restriction 
                                  : w_restriction);
  //cout << "z: " << z << " az: " << az << " w: " << w << " aw: " << aw << "\n"; 
  //cout << "Z restriction: " << z_restriction << "\n";
  //cout << "W restriction: " << w_restriction << "\n";
  //cout << "Computed initial radius as " << chunky_radius << "\n";
}

void ifs::initialize(cpx a, cpx b){
	// initialize z to a and w to b
	z=a;
	w=b;
	az = abs(z);
	aw = abs(w);
	sync=0;
	color_ifs=true;
	chunky_ifs=false;
	disconnection_depth=false;
	draw_trap_mode = false;
	step=0.01;	// size of adjustments to z and w
	seed=0.0;	// initial seed point for IFS
	center=0.0;	// in mandelbrot mode; center of screen, size of window, and mesh of accuracy
	wind=1.0;
	mesh=1;
	depth=12;	  // depth to iterate IFS or detect connectedness to
	trap_depth = depth;  //depth to search for traps 
	compute_chunky_radius();

	
};

cpx ifs::iterate(int index, cpx u){
	// apply generator to u
	if(index==0){
		return(u*z);
	} else {
		return(((u-1.0)*w)+1.0);
	};
};



void ifs::draw_dots(int d, cpx u){
	// draw IFS to depth d with seed u
	if(d<=0){
		draw_point(cpx_to_point(u),0);
	} else {
		draw_dots(d-1, iterate(0,u));
		draw_dots(d-1, iterate(1,u));
	};
};

void ifs::draw_color_dots(int d, cpx u, long color){
	// draw IFS to depth d with seed u
	if(d<=0){
		draw_point(cpx_to_point(u), color);
	} else {
		draw_color_dots(d-1, iterate(0,u), 0xFFAA00);
		draw_color_dots(d-1, iterate(1,u), 0x00AAFF);
	};
};

void ifs::draw_color_chunky_dots(int d, cpx u, long color, double radius) {
	//draw IFS with chunky dots
	if (d<=0) {
	  //the radius should get multiplied by 512
	  double draw_radius = radius*512;
	  if (draw_radius < 1) draw_radius = 1;
		draw_circle(cpx_to_point(u), draw_radius, color);
		//cout << "radius: " << radius;
		//cout << "abs(z): " << abs(z);
	} else {
		draw_color_chunky_dots(d-1, iterate(0,u), 0xFFAA00, radius*az);
		draw_color_chunky_dots(d-1, iterate(1,u), 0x00AAFF, radius*aw);
	}
}

void ifs::draw_limit_set(){
	// draw IFS and write values of parameters to screen
	stringstream T;
	point p;
	
	if(sync==1){
		w=z;
		aw = az;
	} else if(sync==2){
		w=conj(z);
		aw = az;
	};
	erase_field();
	p.x=1200;
	p.y=20;
	T << "limit set (IFS attractor)";
	draw_text(p,T,0x000000);
	T.str("");
	p.y=p.y+20;	
	T << "z (adjust with [arrows]): " << z;
	draw_text(p,T,0x000000);
	T.str("");
	p.y=p.y+20;	
	T << "w (adjust with [ijkl]): " << w;
	draw_text(p,T,0x000000);
	T.str("");
	p.y=p.y+20;
	T << "depth (adjust with [d/e]): " << depth;
	draw_text(p,T,0x000000);
	T.str("");	
	p.y=p.y+20;
	T << "step (adjust with [a/s]): " << step;
	draw_text(p,T,0x000000);
	T.str("");		
	p.y=p.y+20;
	T << "sync w free, w=z, w=conj(z) (cycle with [v]): " << sync;
	draw_text(p,T,0x000000);
	T.str("");		
	p.y=p.y+20;
	if (draw_trap_mode) {
		if (find_trap()) {
			T << "trap found (toggle trap mode with [t])";
			draw_trap();
		} else {
			T << "trap not found (toggle trap mode with [t])";
		}
	} else {
		T << "trap drawing disabled (toggle trap mode with [t])";
	}
	draw_text(p,T,0x000000);
	T.str("");
	p.y=p.y+20;
	T << "2-color IFS (toggle with [c]): ";
	if(color_ifs){
		T << "on";
	} else {
		T << "off";
	};
	draw_text(p,T,0x000000);
	T.str("");		
	p.y=p.y+20;
	T << "chunky IFS (toggle with [x], adjust radius with l/r brackets): ";
	if (chunky_ifs) {
		T << "on (radius: " << chunky_radius << ")";
	} else {
		T << "off";
	}
	draw_text(p,T,0);
	T.str("");
	p.y=p.y+20;	
	T << "connected: ";
	if(circ_connected()){
		T << "yes";
	} else {
		T << "no";
	};
	draw_text(p,T,0x000000);
	T.str("");	
	p.y=p.y+20;
	T << "toggle ifs/mandelbrot with [b]";
	draw_text(p,T,0x000000);
	T.str("");
	p.y=p.y+20;
	T << "quit with [q]";
	draw_text(p,T,0x000000);
	T.str("");	
	if(color_ifs){
		if (chunky_ifs) {
		  compute_chunky_radius();
		  //cout << "Chunky radius: " << chunky_radius << "\n";
			draw_color_chunky_dots(depth,seed,0x000000,chunky_radius);
		} else {
			draw_color_dots(depth,seed,0x000000);	// actual IFS is drawn
		}
	} else {
		draw_dots(depth,seed);
	};
	draw_dot(cpx_to_point(z),0xFF0000);	// z
	draw_dot(cpx_to_point(1.0-w),0x00FF00);	// 1-w
	draw_dot(cpx_to_point(0.0),0xBDB76B);	// 0
	draw_dot(cpx_to_point(1.0),0xBDB76B);	// 1
};

void ifs::zoom(point p){
	// in mandelbrot
	cpx cc;
	cc=point_to_cpx(p);
	center=(cc*wind)+center;
	wind=wind/2.0;
	mesh=mesh*2;
};

void ifs::draw_mandelbrot_set(){
	// draw mandelbrot set (connectedness locus) and write values of parameters to screen
	stringstream T;
	point p,q;
	cpx zz;
	int i,j;
	double x,y;
	
	erase_field();
	
	p.x=1200;	// 1200
	p.y=20;
	T << "connectedness locus";
	draw_text(p,T,0x000000);
	T.str("");
	p.y=p.y+20;
	T << "slice: ";
	if(sync==0){
		T << "w=" << w << "\n";
	} else if(sync==1){
		T << "w=z\n";
	} else if(sync==2){
		T << "w=conj(z)\n";
	};
	draw_text(p,T,0x000000);
	T.str("");
	p.y=p.y+20;
	T << "cycle slice type with [v]\n";
	draw_text(p,T,0x000000);
	T.str("");		
	p.y=p.y+20;
	T << "depth (adjust with [d/e]): " << depth;
	draw_text(p,T,0x000000);
	T.str("");
	p.y=p.y+20;
	T << "center (adjust by mouse click): " << center;
	draw_text(p,T,0x000000);
	T.str("");
	p.y=p.y+20;
	T << "window (zoom out with [g]): " << wind;
	draw_text(p,T,0x000000);
	T.str("");
	p.y=p.y+20;
	T << "mesh (adjust with [n/m]): " << mesh;
	draw_text(p,T,0x000000);
	T.str("");
	p.y=p.y+20;
	T << "toggle ifs/mandelbrot with [b]";
	draw_text(p,T,0x000000);
	T.str("");
	p.y=p.y+20;
	T << "toggle disconnection depth with [f]";
	draw_text(p,T,0x000000);
	T.str("");
	p.y=p.y+20;
	T << "quit with [q]";
	draw_text(p,T,0x000000);
	T.str("");	
	
	for(i=0;i<1024;i=i+mesh){
		for(j=0;j<1024;j=j+mesh){
			q.x=i;
			q.y=j;
			x=2.0*wind*((double) i)/1024.0;
			y=2.0*wind*((double) 1024-j)/1024.0;
			
			z=center-wind-(wind*I)+x+(y*I);
			if(sync==1){
				w=z;	// diagonal slice; could define other slices (eg w=constant,w=conj(z))
			} else if(sync==2){
				w=conj(z);
			};
			if(abs(z)>1.0){	// could truncate this to sqrt(1/2) actually
				draw_box(q,mesh,0x000000);
			} else { // if(abs(z)>0.5){
				if(circ_connected()){
					draw_box(q,mesh,0x000001*exit_depth);
				} else if (disconnection_depth) {
					draw_box(q,mesh,0x010000*exit_depth);
				}
			};
			
	
		};
	};
};

void ifs::draw(){
	if(mode==0){
		draw_limit_set();
	} else if(mode==1){
		draw_mandelbrot_set();
	};
};